<!--
@license
Copyright 2017 Canoo Engineering AG.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
--><link rel="import" href="../polymer/polymer-element.html">

<dom-module id="dolphin-controller">

  <script>
var STATUS_READY = "READY";
var STATUS_NOT_READY = "NOT-READY";

/**
 * The `dolphin-controller` element serves as a Dolphin controller.
 *
 * ~~~html
 * <dolphin-controller
 *   name="MovieController"
 *   model="{{movies}}"></dolphin-controller>
 * ~~~
 *
 * @customElement
 * @polymer
 */

var DolphinController = function (_Polymer$Element) {
  babelHelpers.inherits(DolphinController, _Polymer$Element);
  babelHelpers.createClass(DolphinController, null, [{
    key: "is",
    get: function get() {
      return "dolphin-controller";
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        /**
         * The `ClientContext` of the Dolphin JavaScript client, which should be already
         * connected. Defaults to `window.clientContext`.
         */
        clientContext: {
          type: Object,
          value: function value() {
            return window.clientContext;
          }
        },

        /**
         * The status of the Dolphin controller. Either "READY" or "NOT-READY". Initially
         * is set to "NOT-READY".
         */
        status: {
          type: String,
          value: STATUS_NOT_READY
        },

        /**
         * The name of the Dolphin controller.
         */
        name: String,

        /**
         * The model object graph. Receives changes from Dolphin and notifies Dolphin
         * when was changed.
         *
         * @type {Object}
         */
        model: {
          type: Object,
          notify: true,
          readOnly: false
        },

        /**
         * If true, prevents creation of Dolphin controller when the element is attached
         * to the DOM tree.
         */
        noCreate: {
          type: Boolean,
          value: false
        },

        /**
         * If true, prevents destruction of Dolphin controller when the element is detached
         * from the DOM tree.
         */
        noDestroy: {
          type: Boolean,
          value: false
        }
      };
    }
  }, {
    key: "observers",
    get: function get() {
      return ["_onClientContextChanged(clientContext)", "_onModelChanged(model.*)"];
    }
  }]);

  function DolphinController() {
    babelHelpers.classCallCheck(this, DolphinController);

    var _this = babelHelpers.possibleConstructorReturn(this, (DolphinController.__proto__ || Object.getPrototypeOf(DolphinController)).call(this));

    _this._initBeanRegistry();
    return _this;
  }

  babelHelpers.createClass(DolphinController, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      babelHelpers.get(DolphinController.prototype.__proto__ || Object.getPrototypeOf(DolphinController.prototype), "connectedCallback", this).call(this);

      if (isTruthy(this.noCreate)) {
        return;
      }
      this.create();
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      babelHelpers.get(DolphinController.prototype.__proto__ || Object.getPrototypeOf(DolphinController.prototype), "disconnectedCallback", this).call(this);

      if (isTruthy(this.noDestroy)) {
        return;
      }
      this.destroy();
    }

    /**
     * Creates a Dolphin controller.
     */

  }, {
    key: "create",
    value: function create() {
      var _this2 = this;

      if (isNil(this.clientContext) || isNil(this.name)) {
        return;
      }

      this._onControllerInitializing();
      this.clientContext.createController(this.name).then(function (controller) {
        _this2._onControllerCreated(controller);
        if (!isNil(controller.onDestroyed)) {
          controller.onDestroyed(function () {
            _this2._onControllerDestroyed(controller);
          });
        }
      });
    }

    /**
     * Destroys a Dolphin controller.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (isNil(this._controller)) {
        return;
      }

      this._controller.destroy();
    }

    /**
     * Invokes a Dolphin action.
     *
     * @param {string} name Name of the action
     * @param {any[]} params Array of params for the action
     */

  }, {
    key: "invoke",
    value: function invoke(name, params) {
      return this._controller.invoke(name, params);
    }

    /**
     * Called when the controller is initializing.
     */

  }, {
    key: "_onControllerInitializing",
    value: function _onControllerInitializing() {
      this._controller = null;
      this.status = STATUS_NOT_READY;
    }

    /**
     * Called when the controller was created.
     *
     * @param {any} controller The controller
     */

  }, {
    key: "_onControllerCreated",
    value: function _onControllerCreated(controller) {
      this._controller = controller;
      this.status = STATUS_READY;

      // `this._controller.model` and `this.model` will refer to the same object.
      this._onRootBeanChanged(this._controller.model);
    }

    /**
     * Called when the controller was destroyed.
     *
     * @param {any} controller The controller
     */

  }, {
    key: "_onControllerDestroyed",
    value: function _onControllerDestroyed(controller) {
      this._onRootBeanChanged(this._controller.model);

      this._controller = null;
      this.status = STATUS_NOT_READY;
    }

    /**
     *
     */

  }, {
    key: "_onClientContextChanged",
    value: function _onClientContextChanged() {
      if (isNil(this.clientContext)) {
        return;
      }

      this._beanManager = this.clientContext.beanManager;
      this._beanManager.onBeanUpdate(this._onBeanPropertyChanged.bind(this));
      this._beanManager.onArrayUpdate(this._onBeanPropertySpliced.bind(this));
    }

    /**
     * Notifies the Dolphin server about bean property value changes.
     *
     * @param {object} bean Bean with the changed property
     * @param {string} propertyName Property name of the changed value
     * @param {any} newValue New value
     * @return {any} Old value
     */

  }, {
    key: "_notifyBeanPropertyChanged",
    value: function _notifyBeanPropertyChanged(bean, propertyName, newValue) {
      if (this.status !== STATUS_READY) {
        return;
      }

      return this._beanManager.notifyBeanChange(bean, propertyName, newValue);
    }

    /**
     * Notifies the Dolphin server about bean property array splices.
     *
     * @param {object} bean Bean with the spliced array property
     * @param {string} propertyName Property name of the spliced array
     * @param {number} startIndex Index at which the change occurred
     * @param {any[]} removedItems Array of items that were removed from this index
     * @param {number} addedCount Number of items that were added at this index
     */

  }, {
    key: "_notifyBeanPropertySpliced",
    value: function _notifyBeanPropertySpliced(bean, propertyName, startIndex, removedItems, addedCount) {
      if (this.status !== STATUS_READY) {
        return;
      }

      return this._beanManager.notifyArrayChange(bean, propertyName, startIndex, addedCount, removedItems);
    }

    /**
     * Receives an initial bean from the Dolphin server.
     *
     * @param {object} bean Initial bean at the root
     */

  }, {
    key: "_onRootBeanChanged",
    value: function _onRootBeanChanged(bean) {
      this.set("model", bean);
      if (isObject(bean)) {
        this._bindBean(bean, "model");
      }
    }

    /**
     * Receives a bean property change from the Dolphin server.
     *
     * @param {object} bean Bean with the changed property
     * @param {string} propertyName Property name of the changed value
     * @param {any} newValue New value
     * @param {any} oldValue Old value
     */

  }, {
    key: "_onBeanPropertyChanged",
    value: function _onBeanPropertyChanged(bean, propertyName, newValue, oldValue) {
      // TODO(hastebrot): Maybe use bean[propertyName] instead of oldValue?
      if (isEqual(newValue, oldValue)) {
        return;
      }

      var propertyPaths = this._queryPropertyPaths(bean);
      if (propertyPaths.size > 0) {
        // HERE: is it ok to fire property changes only for the first element?
        var parentPropertyPath = Array.from(propertyPaths)[0];
        var propertyPath = this._buildPropertyPath(parentPropertyPath, propertyName);
        this.set(propertyPath, newValue);
      } else {
        bean[propertyName] = newValue;
      }
    }

    /**
     * Receives a bean property splice from the Dolphin server.
     *
     * @param {object} bean Bean with the spliced array property
     * @param {string} propertyName Property name of the spliced array
     * @param {number} startIndex Index at which the change occurred
     * @param {number} removedCount Number of items that were removed from this index
     * @param {any[]} addedItems Array of items that were added at this index
     */

  }, {
    key: "_onBeanPropertySpliced",
    value: function _onBeanPropertySpliced(bean, propertyName, startIndex, removedCount, addedItems) {
      var items = bean[propertyName];
      var removedItems = items.slice(startIndex, startIndex + removedCount);
      if (isArrayEqual(addedItems, removedItems)) {
        return;
      }

      var propertyPaths = this._queryPropertyPaths(bean);
      if (propertyPaths.size > 0) {
        // HERE: is it ok to fire property changes only for the first element?
        var parentPropertyPath = Array.from(propertyPaths)[0];
        var propertyPath = this._buildPropertyPath(parentPropertyPath, propertyName);
        this.splice.apply(this, [propertyPath, startIndex, removedCount].concat(babelHelpers.toConsumableArray(addedItems)));
      } else {
        var _bean$propertyName;

        (_bean$propertyName = bean[propertyName]).splice.apply(_bean$propertyName, [startIndex, removedCount].concat(babelHelpers.toConsumableArray(addedItems)));
      }
    }

    /**
     * Receives changes of the `model` property and its subproperties.
     *
     * @param {any} changeRecord Record with change information
     */

  }, {
    key: "_onModelChanged",
    value: function _onModelChanged(changeRecord) {
      var _this3 = this;

      if (this.status !== STATUS_READY) {
        return;
      }
      // console.log(pretty1(changeRecord))

      /**
       * Handles a bean property change.
       */
      var handleBeanPropertyChanged = function handleBeanPropertyChanged(rootProperty, propertyPath, newValue) {
        var parentPropertyPath = _this3._slicePropertyPath(propertyPath, 0, -1);
        var propertyName = _this3._slicePropertyPath(propertyPath, -1);
        var bean = Polymer.Path.get(rootProperty, parentPropertyPath);
        var property = Polymer.Path.get(rootProperty, propertyPath);

        // Ignore replacing an array using Polymer. This will cause stray beans in bean registry.
        if (isArray(property)) {
          return;
        }

        // Ignore array.length change records from Polymer.
        if (propertyName === "length" && isArray(bean)) {
          return;
        }

        // Ignore non-beans.
        if (!isNil(bean)) {
          var oldValue = _this3._notifyBeanPropertyChanged(bean, propertyName, newValue);
          _this3._updateBeanBinding(propertyPath, newValue, oldValue);
        }

        // console.log("changed path:", pretty1(propertyPath))
        // console.log("registered paths:", pretty1(this._beanRegistry.values()))
      };

      /**
       * Handles a bean property splice.
       */
      var handleBeanPropertySpliced = function handleBeanPropertySpliced(rootProperty, propertyPath, spliceRecords) {
        var parentPropertyPath = _this3._slicePropertyPath(propertyPath, 0, -1);
        var propertyName = _this3._slicePropertyPath(propertyPath, -1);
        var bean = Polymer.Path.get(rootProperty, parentPropertyPath);
        var property = Polymer.Path.get(rootProperty, propertyPath);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = spliceRecords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var spliceRecord = _step.value;
            var items = spliceRecord.items,
                startIndex = spliceRecord.startIndex,
                removedItems = spliceRecord.removedItems,
                addedCount = spliceRecord.addedCount;

            _this3._notifyBeanPropertySpliced(bean, propertyName, startIndex, removedItems, addedCount);
            _this3._updateArrayBindings(propertyPath, items, startIndex, removedItems, addedCount);
          }

          // console.log("spliced path:", pretty1(propertyPath))
          // console.log("registered paths:", pretty1(this._beanRegistry.values()))
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      var hasSpliceRecords = function hasSpliceRecords(changeRecord) {
        var value = changeRecord.value,
            path = changeRecord.path,
            base = changeRecord.base;

        return value && !isNil(value.indexSplices) && path.endsWith(".splices");
      };

      var toSpliceRecord = function toSpliceRecord(indexSplice) {
        var object = indexSplice.object,
            index = indexSplice.index,
            removed = indexSplice.removed,
            addedCount = indexSplice.addedCount;

        return { items: object, startIndex: index, removedItems: removed, addedCount: addedCount };
      };

      var newValue = changeRecord.value;
      // const rootProperty = changeRecord.base
      // const propertyPath = this._slicePropertyPath(changeRecord.path, 1)
      var rootProperty = { model: changeRecord.base };
      var propertyPath = changeRecord.path;

      // Change record for array splices.
      if (hasSpliceRecords(changeRecord)) {
        var splicePropertyPath = this._slicePropertyPath(propertyPath, 0, -1);
        var spliceRecords = newValue.indexSplices.map(function (it) {
          return toSpliceRecord(it);
        });
        handleBeanPropertySpliced(rootProperty, splicePropertyPath, spliceRecords);
      }
      // Change record for subproperty updates.
      else {
          handleBeanPropertyChanged(rootProperty, propertyPath, newValue);
        }
    }

    /**
     * Update bean bindings.
     *
     * @param {string} propertyPath Property path of the items
     * @param {any} newValue New value
     * @param {any} oldValue Old value
     */

  }, {
    key: "_updateBeanBinding",
    value: function _updateBeanBinding(propertyPath, newValue, oldValue) {
      if (!isNil(oldValue)) {
        this._unbindBean(oldValue, propertyPath);
      }

      if (!isNil(newValue)) {
        this._bindBean(newValue, propertyPath);
      }
    }

    /**
     * Update array bindings.
     *
     * @param {string} propertyPath Property path of the items
     * @param {any[]} items Array of current items
     * @param {number} startIndex Index at which the change occurred
     * @param {any[]} removedItems Array of items that were removed from this index
     * @param {number} addedCount Number of items that were added at this index
     */

  }, {
    key: "_updateArrayBindings",
    value: function _updateArrayBindings(propertyPath, items, startIndex, removedItems, addedCount) {
      for (var removedIndex = 0; removedIndex < removedItems.length; removedIndex++) {
        var removedItem = removedItems[removedIndex];
        var itemPropertyPath = this._buildPropertyPath(propertyPath, startIndex + removedIndex);
        this._unbindBean(removedItem, itemPropertyPath);
      }

      // HERE: is the name `addedIndex` appropriate?
      for (var addedIndex = startIndex + addedCount; addedIndex < items.length; addedIndex++) {
        var addedItem = items[addedIndex];
        var _itemPropertyPath = this._buildPropertyPath(propertyPath, addedIndex - addedCount + removedItems.length);
        this._unbindBean(addedItem, _itemPropertyPath);
      }

      for (var itemIndex = startIndex; itemIndex < items.length; itemIndex++) {
        var item = items[itemIndex];
        var _itemPropertyPath2 = this._buildPropertyPath(propertyPath, itemIndex);
        this._bindBean(item, _itemPropertyPath2);
      }
    }

    /**
     * Bind bean and nested beans.
     */

  }, {
    key: "_bindBean",
    value: function _bindBean(bean, propertyPath) {
      var _this4 = this;

      // Return, if `bean` is not a bean.
      if (isNil(bean) || !isObject(bean)) {
        return;
      }

      this._registerPropertyPath(bean, propertyPath);

      forEach(bean, function (childBean, propertyName) {
        var childPropertyPath = _this4._buildPropertyPath(propertyPath, propertyName);
        _this4._bindBean(childBean, childPropertyPath);
      });
    }

    /**
     * Unbind bean and nested beans.
     */

  }, {
    key: "_unbindBean",
    value: function _unbindBean(bean, propertyPath) {
      var _this5 = this;

      // Return, if `bean` is not a bean.
      if (isNil(bean) || !isObject(bean)) {
        return;
      }

      this._unregisterPropertyPath(bean, propertyPath);

      forEach(bean, function (childBean, propertyName) {
        var childPropertyPath = _this5._buildPropertyPath(propertyPath, propertyName);
        _this5._unbindBean(childBean, childPropertyPath);
      });
    }

    /**
     * Initialize bean registry.
     */

  }, {
    key: "_initBeanRegistry",
    value: function _initBeanRegistry() {
      this._beanRegistry = new Map();
    }

    /**
     * Query property paths of bean.
     */

  }, {
    key: "_queryPropertyPaths",
    value: function _queryPropertyPaths(bean) {
      return this._beanRegistry.get(bean) || new Set();
    }

    /**
     * Register property path into bean registry.
     */

  }, {
    key: "_registerPropertyPath",
    value: function _registerPropertyPath(bean, propertyPath) {
      var propertyPaths = this._queryPropertyPaths(bean);
      if (propertyPaths.size === 0) {
        this._beanRegistry.set(bean, propertyPaths);
      }
      propertyPaths.add(propertyPath);
    }

    /**
     * Unregister property path from bean registry.
     */

  }, {
    key: "_unregisterPropertyPath",
    value: function _unregisterPropertyPath(bean, propertyPath) {
      var propertyPaths = this._queryPropertyPaths(bean);
      propertyPaths.delete(propertyPath);
      if (propertyPaths.size === 0) {
        this._beanRegistry.delete(bean);
      }
    }

    /**
     * Build property path.
     */

  }, {
    key: "_buildPropertyPath",
    value: function _buildPropertyPath() {
      for (var _len = arguments.length, propertyPathElements = Array(_len), _key = 0; _key < _len; _key++) {
        propertyPathElements[_key] = arguments[_key];
      }

      // TODO(hastebrot): Only remove first element if it is an empty string.
      return Polymer.Path.normalize(propertyPathElements.filter(function (it) {
        return !isEmptyString(it);
      }));
    }

    /**
     * Slice property path.
     */

  }, {
    key: "_slicePropertyPath",
    value: function _slicePropertyPath(propertyPath, start) {
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      var propertyPathElements = Polymer.Path.split(propertyPath);
      return Polymer.Path.normalize(propertyPathElements.slice(start, end));
    }
  }]);
  return DolphinController;
}(Polymer.Element);

window.customElements.define(DolphinController.is, DolphinController);

function pretty(value) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  function replacer(key, value) {
    if (value && value[Symbol.iterator] && !isArray(value)) {
      var array = Array.from(value);
      if (array && !isArrayEqual(array, value)) {
        return array;
      }
    }
    return value;
  }
  return JSON.stringify(value, replacer, padding);
}

function pretty1(value) {
  var string = pretty(value, 1);
  return string.split("\n").map(function (it) {
    return it.trim();
  }).join(" ");
}

function pretty0(value) {
  return pretty(value, 0);
}

/**
 * True, if `value` is an object.
 */
function isObject(value) {
  return (typeof value === "undefined" ? "undefined" : babelHelpers.typeof(value)) === "object";
}

/**
 * True, if `value` is an array.
 */
function isArray(value) {
  return Array.isArray(value);
}

/**
 * True, if `value` is `null` or `undefined`.
 */
function isNil(value) {
  return value === null || value === undefined;
}

/**
 * True, if `value` is truthy.
 */
function isTruthy(value) {
  return !!value;
}

function isEmptyString(value) {
  return value === "";
}

function isEqual(a, b) {
  return a === b;
  // return Object.is(a, b)
}

/**
 * Compares if one array is equal to another array.
 *
 * @param {Array} a One array
 * @param {Array} b Another array
 * @returns {boolean} True, if the array is equal to the other array
 */
function isArrayEqual(a, b) {
  if (a === b || isNil(a) && isNil(b)) {
    return true;
  }
  if (isNil(a) !== isNil(b)) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }

  for (var index = 0; index < a.length; index++) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}

/**
 *
 */
function forEach(collection, callback) {
  Object.keys(collection).forEach(function (key) {
    return callback(collection[key], key, collection);
  });
}

// function forEach(collection, callback) {
//   if (isArray(collection)) {
//     const array = collection
//     for (let itemIndex = 0; itemIndex < array.length; itemIndex++) {
//       const item = array[itemIndex]
//       callback(item, itemIndex, array)
//     }
//     return array
//   }
//   if (isObject(collection)) {
//     const object = Object(collection)
//     for (let propertyName in object) {
//       if (object.hasOwnProperty(propertyName)) {
//         const property = object[propertyName]
//         callback(property, propertyName, object)
//       }
//     }
//     return object
//   }
//   return collection
// }</script>

</dom-module>
